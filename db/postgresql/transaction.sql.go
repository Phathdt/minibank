// Code generated by sqlc. DO NOT EDIT.
// source: transaction.sql

package postgresql

import (
	"context"
)

const insertTransaction = `-- name: InsertTransaction :one
INSERT INTO transactions (from_account_id, to_account_id, amount)
		VALUES($1, $2, $3)
	RETURNING id, from_account_id, to_account_id, amount, type, created_at, updated_at
`

type InsertTransactionParams struct {
	FromAccountID int64 `json:"from_account_id"`
	ToAccountID   int64 `json:"to_account_id"`
	Amount        int64 `json:"amount"`
}

func (q *Queries) InsertTransaction(ctx context.Context, arg InsertTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, insertTransaction, arg.FromAccountID, arg.ToAccountID, arg.Amount)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.Amount,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listTransactions = `-- name: ListTransactions :many
SELECT
	t.id, t.from_account_id, t.to_account_id, t.amount, t.type, t.created_at, t.updated_at
FROM
	transactions t
	JOIN accounts a ON t.from_account_id = a.id OR t.to_account_id = a.id
	JOIN users u ON u.id = a.user_id
WHERE
	u.id = $1
ORDER BY t.id DESC
`

func (q *Queries) ListTransactions(ctx context.Context, id int64) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactions, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.Amount,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByAccount = `-- name: ListTransactionsByAccount :many
SELECT
	t.id, t.from_account_id, t.to_account_id, t.amount, t.type, t.created_at, t.updated_at
FROM
	transactions t
	JOIN accounts a ON t.from_account_id = a.id OR t.to_account_id = a.id
	JOIN users u ON u.id = a.user_id
WHERE
	u.id = $1 AND a.id = $2
ORDER BY t.id
`

type ListTransactionsByAccountParams struct {
	ID   int64 `json:"id"`
	ID_2 int64 `json:"id_2"`
}

func (q *Queries) ListTransactionsByAccount(ctx context.Context, arg ListTransactionsByAccountParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsByAccount, arg.ID, arg.ID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.Amount,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Code generated by sqlc. DO NOT EDIT.
// source: transaction.sql

package postgresql

import (
	"context"
)

const insertTransaction = `-- name: InsertTransaction :one
INSERT INTO transactions (account_id, amount, transaction_type)
		VALUES($1, $2, $3)
	RETURNING id, account_id, amount, transaction_type, created_at, updated_at
`

type InsertTransactionParams struct {
	AccountID       int64  `json:"account_id"`
	Amount          int64  `json:"amount"`
	TransactionType string `json:"transaction_type"`
}

func (q *Queries) InsertTransaction(ctx context.Context, arg InsertTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, insertTransaction, arg.AccountID, arg.Amount, arg.TransactionType)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Amount,
		&i.TransactionType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listTransactions = `-- name: ListTransactions :many
SELECT
	t.id, t.account_id, t.amount, t.transaction_type, t.created_at, t.updated_at
FROM
	transactions t
	JOIN accounts a ON t.account_id = a.id
	JOIN users u ON u.id = a.user_id
WHERE
	u.id = $1
ORDER BY t.id DESC
`

func (q *Queries) ListTransactions(ctx context.Context, id int64) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactions, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Amount,
			&i.TransactionType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByAccount = `-- name: ListTransactionsByAccount :many
SELECT
	t.id, t.account_id, t.amount, t.transaction_type, t.created_at, t.updated_at
FROM
	transactions t
	JOIN accounts a ON t.account_id = a.id
	JOIN users u ON u.id = a.user_id
WHERE
	u.id = $1 AND t.account_id = $2
ORDER BY t.id
`

type ListTransactionsByAccountParams struct {
	ID        int64 `json:"id"`
	AccountID int64 `json:"account_id"`
}

func (q *Queries) ListTransactionsByAccount(ctx context.Context, arg ListTransactionsByAccountParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsByAccount, arg.ID, arg.AccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Amount,
			&i.TransactionType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
